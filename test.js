/*
const newPost = function (post, addedAt = Date())  {
  return {
  ...post,
  addedAt,  
};
}
const firstPost = {
  id: 1,
  author: 'Slava',
}
console.log(newPost(firstPost))
*/

//------------------------------------------

/*
setTimeout(()=>{
  console.log('отложенное')
}, 1000) 
*/

//------------------------------------------
/*
const c = (a, b) => a+b
console.log(c(2, 3))
*/

//------------------------------------------
/*
const mul = (value, multi = 1) => {
  return value * multi
} 
mul(2, 2)
*/

/*
const fnWithError = () => {
  throw new Error('Some error')
}
try {
  fnWithError()
}
catch (error) {
  console.error(error)
  console.log(error.message)
}
console.log('Continue...')
*/
/*
создаем константу приравниваем ее к стрелочной функции в которой 
вброшена ошибка, в труй выводим функцию с ошибкой(не выводится).
в кетч создаем вывод ошибки(красным) и сообщение об ошибке
выводим сообщение продолжить
*/
//------------------------------------------------------------



//  МАССИВЫ
/*
const myArray = [1, true, 'SLAVA',4,5] // 
console.log(myArray)
console.log(myArray.length)
*/

// const myArray = [1, true , 'a', 4, 5, 6]
// console.log(myArray) //[1, true, 'a']

// console.log(myArray[0]) // 1
// console.log(myArray[1]) // true

// var myVar = 1;

// function setMyVar(){
//   myVar = 2; 
// }
// setMyVar();
// console.log(myVar)


// let myLet = 'lalala';
// console.log(myLet)
// myLet = 'alal'
// console.log(myLet)

// let myConst = myLet;
// console.log(myConst)

// let myAge = 25;

// function myFn() {
//   let myAge = 12;
//   console.log(myAge);
// }
// myFn();
// console.log(myAge)


// "use strict"

// age = 25;
// console.log(age);

// var age;

// if (true) {
//   var size = 50;
// }

// console.log(size)

// придумать имя переменной для хранения цвета глаз пользователя сайта
// объявить две переменнные User и userName, присвоить значение Вася переменной userName
// скопировать значение переменной userName в переменную user, вывести в консоль переменную юзер(рузультат Вася)

// let user 
// {
//     userName = 'Вася'
// user = userName;
// console.log(user)
// }

// if (true) {
//   let size = 50;
// }

// console.log(size)



// function myMn(age) {
// if(age > 18){
//   console.log('ты старый, пора на пенсию')
// }
// else{
//   console.log('пока ты молодой')
// }
// if(age < 19) {
//   for (age ; age < 19; age++ )
//   console.log('теперь тебе ' + age)
//   console.log('старпер, так и жизнь пройдет ;D')
//   if(age++){
//     console.log('чуешь, как быстро летит время?')
//   }
//   }

// }
// myMn(12)



// const myArray = [1,2,3]
// console.log(myArray)
// myArray.map((el) => console.log(el*2))
// console.log(myArray)
// console.log(myArray)



          // function myFn (a, b) {
          // let c = a*b
          // return c
          // }
          // console.log(myFn(2, 4))




          //  let name = 'ivan ',
          //    surname = 'petrov ',
          //    age = 17

          //   function myFn (){
          //     let inf = 'привет ' + name + surname + 'возрастом ' + age + ' лет';
          //     return inf
          //   }

          //   console.log(myFn())



              // function myFn(string) {
              //   if (string == 'm'){
              //     return 'вы мужик'            
              //  }
              //  else if (string == 'w'){
              //   return 'вы женщина'
              //  }
              //  else {
              //   return ' вы оно'
              //  }
              // }
              
              // console.log(myFn(''))




              // function day(number) {
              //   if(number == 1){
              //     return 'понедельник'
              //   }
              //    else if(number == 2){
              //     return 'вторник'
              //   }
              //   else if(number == 3){
              //     return 'среда'
              //   }
              //   else if(number == 4){
              //     return 'четверг'
              //   }
              //   else if(number == 5){
              //     return 'пятница'
              //   }
              //   else if(number == 6){
              //     return 'суббота'
              //   }
              //   else if(number == 7){
              //     return 'воскресение'
              //   }
              //   else{
              //     return 'нет такого дня недели'
              //   }
              // }
              // console.log(day(9))




            //   let myString = 'мама мыла раму. пес рубит дрова. редиска метет пол. кошка какает на пол.'

            //   var firstWord = myString.replace(/ .*/,'');

            // console.log(firstWord)

              

// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------

Практически все сущности в js это объекты
Объект - набор свойств "имя: значение"

пример объекта: 
{
  visible: true,
  colorDepth: 24,
  title: 'My Image',
  orientation: {
    angle: 0,
    type: 'landscape'
  },
  pixelDepth: 24,
  width: 1440
}

объект нахлдится между парой фигурных скобок и между ними находятся пары( ключ: значение)
значение свойства orientation - вложеный объект(у него есть свои свойства)

Массив в JS - объект
Функция в JS - объект
Число в JS - ведут себя как объекты(примитив)
Строка в JS - ведут себя как объекты(примитив)


console.log('Hello World') - выражение

console - объект
log - метод (это функция которая является значением одного из свойств объекта) - у нашего объекта console есть свойство,
 значение которого - это функция, а такие свойства называются методами(log- метод)
 Точка между console и log - это синтаксис JS , которая называется точечной записью. С помощью точечной записи можно получать доступ к 
 сво2йствам объекта. В данном случае мы получаем с помощью точечной записи доступ к методу объекта, метод называется log
 Скобки это вызов метода - это также часть синтакчиса JS. Поставив скобки после log мы говорим, что хотим вызвать эту функцию,
 которая является методом объекта console - вызавается метод log
 Внутри вызова метода находится аргумент и в данном примере - это просто значение типа строка(string).
 Значение типа строка помощаются в JS либо в одинарные кавычки, либо в двойные -  это описание команды console.log


 Кроме метода log, у console, есть такие методы, как dir - с помощью этого метода можно отобразить все свойства того или иного объета
 с помощью console.dir() - можно увидеть, что любая функция в JS - это объект и увидеть все свойства этого объекта

Также есть метод table() и с помощью него можно в консоли увидеть все свойства объекта, который передан в этот метод
как аргумент(будет находится между скобками) в табличном виде

console.table() - можно использовать в консоли браузера и в интерпритаторе Node.js

Пример: console.log('slava') -  в консоле браузера увидим slava и ответ от интерпритатора JS - undefined - то что видим на этом этапе - 
это результат этого выражения

Любое выражение возвращает значение (в данном случае undefined)

у объекта console - есть ряд свойств(пример: log)

Вызов функции - это выражение, потому что вызов функции всегда возвращает значение


ВЫРАЖЕНИЯ

Любое выражение всегда возвращает значение, это самое важное в понимании того, что такое выражение

Примеры выражений:

'abc' - строка( результат этого выражения - эта же строка)

10 - число - это тоже выражение, если мы передадим это число интерпритатору JS, он нам вернет этоже значение - 10

5+2 - тоже выражение, но здесь испорльзуется оператор + и результатом такого выражения будет число 7

с = 10 - оператор присвоения = и в данном примере число 10 присваивается переменной с названием "с" - это тоже выражение и результатом будет
то значение, которое мы присваиваем переменной "с"

'Good ' + 'Evening' - конкотенация строк с помощью оператора +, результатом этого выражения будет одна строка 'Good Evening'

a <= b || c !== d - выражение с несколькими операторами, такими как "меньше или равно", "или", "неравно"

myFunction(c, d) - вызов функции это тоже выражение, потому что функция всегда возвращает значение
    имя  аргументы


Результатами любого выражения являются значения(через слешы результаты)

'abc' // 'abc'
10 // 10
a + b // сумма 'a' и 'b'
'Good ' + 'Evening' // 'Good Evening'
a <= b || c !== d // true или false
myFunction(c, d) // результат функции


Выражение присваивания a = 20

переменной можно присвоить все что угодно, объект, строку, булевое значение.
Важно понимать, что оператор присвоения = используется в выражении, т.е то что мы видим а = 20 - это выражение, выражение в котором 
значение присваивается переменной.
Здесь мы не объявляем переменную 'а', здесь мы только присваиваем значение


                      Выражения с побочными действиями 

a = 5    - это выражение вернет значение 5, но кроме возвращение, это выражение приведет к выполнению действия,
         значение 5 будет присвоено переменной "а" и позже в коде мы можем обратиться к этой переменной и прочесть это значение
b++    - в этом выражении используется оператор два плюса, он увеличивает значение на единицу, если 'b' было равно 5, то вернется 6

myFunction(c, d) - вызов функции( внутри нее можем выполнять различные действия например обращаться к серверу и получать с него данные, читать 
                                  данные с файла и тд и тп)

выражение, которое не только возвращает значение, но и выполняет какие то действия называется выражением
с побочными действиями (side effects)


                                    ПЕРЕМЕННЫЕ - контейнеры для хранения значений

 Переменные дают возможность повторного доступа к значениям 
 можно перезаписывать значения тех или иных переменных
 Переменную можно рассматривать как коробку и можно положить в нее например свое имя  и на этой коробке можно написать название   
 например myName и в дальнейшем мы можем обратиться к значению этой коробки (распаковать коробку, посмотреть какое значение там находится) 
 и выполнить действия с этим значением. Кроме того можно достать одно значение с этой коробки и положить туда другое значение  
 Можно объединять значения коробок(переменных). Например если у нас есть две строки, присвоенные разным переменным, мы моежм
 орбъединить эти значения и получить новую строку на выходе.

 Переменные рекомендуется называть 

 PascalCase - типы и классы (пример, есть такой класс как Object либо Array)

 DB_PASSWORD - значения известны до запуска приложения и не меняются(например пароли)

 camelCase - для всех остальных случаев(чаще всего)

 НАЗВАНИЯ ПЕРЕМЕННЫХ ДОЛЖНЫ БЫТЬ ПОНЯТНЫМИ!!!!




                          Объявление переменных

ключевые слова для объявления let const var

let и const появились в ECMAScript 6 
ECMAScript - это стандарт JS, который описывает все функции JS, а браузеры применяют этот стандарт

let a    - Объявление переменной с названием "a" (название не понятно, но для примера удобнее). С помощью ключевого слова let
даем инструкцию интерпритатору JS создать новую переменную с названием "a"

a = true    - присваивание значениея true  переменной 'a', переменная была объявлена до этого

const c = 10   - Объявление и присваивание в одной строке

  Разница между let и const

  если объявляем переменную с помощью let(let a = 10), то будет создана переменная 'a' и ей будет присвоено значение '10', далее 
  мы можем переприсваивать значение переменной(новое значение)
  
  Пример: let a = 10  либо   let a
          a = 20             a = 10
                             a = 20

  если используем const, то мы должны в одной строке объявить и присвоить значение переменной
  если попытаемся присвоить новое значение мы получим ошибку       

  ПРАКТИКА ПО СОЗДАНИЮ ПЕРЕМЕННЫХ В ФАЙЛЕ test2.js -1


  Тип переменной определяется типом присвоенного значения
Пример: 
const a = 10  - тип переменной число(Number)
const b = 'abs' - тип переменной строка(String) - переменная b это строка




                                          ТИПЫ - примитивные и ссылочный

Переменная имеет значение => значение имеет тип

ПРИМИТИВНЫЕ ТИПЫ 
если мы присваеваем такие значения переменным, то в памяти компа эти переменные будут непосредственно содержать значения, 
поэтому эти типы называются примитивными

string - строка
boolean - логический (true или false)
number - число
null - ноль - явно указываем, что у какой то переменной на данном этапе значение отсутствует(указываем сами)
undefined - не определено(значения не существует)
symbol - символ, с помощью данного типа можно создавать уникальные значения
BigInt(большое целое) - как number, но оно так же может хранить числа больше двух в 53 степени(к числу добавляется 'n',
что указывает на тип BigInt (19241924124n))

значения примитивных типов:
'Hello World' - строка
undefined - undefined
true - boolean
25 - number


ССЫЛОЧНЫЙ ТИП - всего один

object - объект

Объект - это набор свойств и каждое свойство состоит из названия и значения

Пример: Объект у которого два свойства a и b. Значения ключа(свойства) 'a' - 10, занчение ключа b - true 

 {
  a: 10,
  b: true
 }

 Если мы присваиваем такой объект переменной, то переменная будет хранить лишь ссылку на объект - с массивом тоже самое
         Мы можем иметь несколько одинаковых ссылок в разных местах памяти, которые указывают на один и тот же объект 
            Можно создать сколько угодно переменных ссылающихся на один и тот же объект
                                        
Если мы меняем свойства a и b в объекте (присваиваем новые значения), то поменяв значение свойства объекта в одной 
 переменной , мы поменяем значение в одном месте в памяти и соответственно значения других переменных изменится   

 ПРАКТИКА ПО ССЫЛОЧНЫМ ТИПАМ test2.js -2

Доступ к свойставм того или иного объекта возможен с помощью оператора точка 
                                                                                    const objectA = {
                                                                                      a: 10,
                                                                                      b: true
                                                                                    }
                                                                                    objectA.a = 20

объекту можно добавить новое свойство                                               objectA.c ='abc'




                                                         ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ

    В JS нет необходимости указывать тип переменной, когда мы объявляем переменную или присваиваем ей значение 
Тип переменной будет автоматически меняться в зависимости от ее значения, например:
Если мы изначально присвоили переменной "а" - "abc" ее тип строка,  а потом переприсвоили на 123, то тип переменной автоматически 
изменится на number

JS ДИНАМИЧЕСКИ ТИПИЗИРУЕМЫЙ ЯЗЫК

НЕ НУЖНО НАЗЫВАТЬ ПЕРЕМЕННЫЕ КАК ФУНКЦИИ, ИНАЧЕ ПОСЛЕ СЛУЧАЙНОГО ПЕРЕПРИСВОЕНИЯ ПОЛУЧИМ ОШИБКУ (ЕСТЬ ВЫХОД, ИСПОЛЬЗОВАТЬ const)
пример:
            function a() {
              console.log('hello world')
            }
            a()// 'hello world'
            a = 10
            a() // Uncaught TypeError: a is not a function   - при вызове говорит, что 'a' - это не функция

            ПРАКТИКА ПО ССЫЛОЧНЫМ ТИПАМ test2.js -3         


пример с const:
              const a = () => {
                console.log('hello world')
              }

              a() // 'hello world'

              a = 10 // Assignment to constant variable.  - переприсваивать переменную объявленную с помощью const запрещено 

              a()

const не даст переприсвоить переменную 'a' 



                                                            ОБЪЕКТЫ 

У  объектов есть свойства

если какое то свойство содержит функцию в качестве значения, то такое свойство называется метод

Практически все сущности в JS это объекты, они либо ими являются, либоо вседут себя как объекты(примитивы)

Объект - это набор свойств "имя: значение"

Объект - это тип значений

Объект - это тип переменных

----------------------------------------------------------------------------
пример объекта

const myCity = {
  city: 'Kazan',
  popular: true,
  country: 'Rus'
}

Объект записывается между фигурными скобками
У данного объекта есть три свойства: city, popular, country
Справа после двоеточия - значения соответствующих свойств: Kazan, true, Rus

Иначе эти пары можно назвать: (Ключ: значение)

Порядок свойств не имеет значение

ПОЛУЧЕНИЕ ДОСТУПА К СВОЙСТВАМ ОБЪЕКТА 

const myCity = {
  city: 'kazan',
  popular: true,
  country: 'Rus'                                      
}
console.log(myCity.city) 
myCity.city = 'sarapul' // поменяли значение свойства объекта
console.log(myCity.city) 
console.log(myCity.popular)


Используя точку после названия объекта, мы можем получить доступ к значению свойства объекта // console.log(myCity.city)
Этот синтаксис называется точечная запись(dot notation)

Используя ту же точечную запись можно изменять значене свойств объекта(используется знак присваивания = )

Новое свойство в объектах можно создавать также с помощью точечой записи   myCity.size = 'small'


УДАЛЕНИЕ СВОЙСТВ - происходит с помощью оператора "delete" (пример: delete myCity.country)

ПРАКТИКА ПО ОБЪЕКТАМ test2.js -4


Кроме точечной записи мы можем работать со свойствами объекта используя квадратные скобки 

      const myCity = {
        city: 'kazan'
      }

      myCity['popular'] = true
      console.log(myCity) // {city: 'kazan', popular: true}

Синтаксис с квадратными скобками используется в том случае, если название свойства является значением той или иной переменной

пример(начало кода выше, сейчас просто продолжим код)        ПРАКТИКА ПО квадратным скобкам test2.js -5

      const countryPropertyName = 'country'

      myCity[countryPropertyName] = 'Rus'

      console.log(myCity) // свойство объекта myCity будет называться country, как значение переменной countryPropertyName
                          // мы передаем не имя переменной, а имя свойства переменной 


ВЛОЖЕННОСТЬ (правтика по вложенности test2.js -6)

У объектов в JS могут быть вложенные свойства, которые содержат вложенные объекты

const myCity = {
  city: 'kazan',
  info: {
    isPopular: true,
    country: 'Rus'
  }
}

console.log(myCity.info.isPopular) // true

delete myCity.info['isPopular'] // или   delete myCity.info.isPopular
console.log(myCity)

у объекта myCity есть свойство info и значение этого свойство - объект. Этот объект имеет два своих 
  свойства: isPopular и country(такой объект называется вложенным объектом). У этих вложенных свойств
    также могут быть объекты, как значения и тем самым ВЛОЖЕННОСТЬ МОЖЕТ БЫТЬ МНОГОУРОВНЕВОЙ.
Удалять можно такж, либо используя точечную запись, либо синтаксис с квадратными скобками

ИСПОЛЬЗОВАТЬ СИНТАКСИС С КВАДРАТНЫМИ СКОБКАМИ ТОЛЬКО ТОГДА, КОГДА В КВАДРАТНЫХ СКОБКАХ ДОЛЖНО
  БЫТЬ КАКОЕ ТО ВЫРАЖЕНИЕ, НАПРИМЕР НАЗВАНИЕ ПЕРЕМЕННОЙ 
      

ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ПРИ ФОРМИРОВАНИИ ОБЪЕКТОВ ((практика  test2.js -7))

const name = 'slava'
const postsQty = 23

const userProfile = {
  name: name,
  postsQty: postsQty,
  hasSignedAgreement: false 
}

в этом примере есть две переменные: name и postsQty и эти переменные объявлены с помощью const, значение
переменной name - slava, значение переменной postsQty - 23.
Допустим мы хоти создать новый объект, который будет называться  userProfile  и у этого объекта будут
такие свойства как name  и  postsQty и hasSignedAgreement со значеним false, а вот значения для
свойств postsQty и name должны быть сформированы исходя из значений переменных объявленных ранее name и
postsQty. Мы можем легко использовать переменные в качестве значений для свойств объекта. Более того, 
в качестве значений свойств объекта можно использовать любые выражения и сначала JS получит результат
того или иного выражения, а после этот результат присвоится свойству того или иного объекта.
В данном объекте userProfile свойство name имеет значение переменной name(свойство совпадает с именем
  переменной), точно так же для postsQty. 

В JS есть возможность сокращенной записи свойств при формировании таких объектов

const name = 'slava'
const postsQty = 23

const userProfile = {
  name,
  postsQty,
  hasSignedAgreement: false 
}

в данном случаем можно просто писать переменную в качестве свойства


                        ГЛОБАЛЬНЫЕ ОБЪЕКТЫ
              
существуют глобальные объекты:
window - в браузере
global - в node.js

Если в консоли браузера набрать window, мы получим объект с огромным количеством свойст и методов, в
этом глобальном объекте присутствуют методы и свойства, которые доступны в браузере по умолчанию т.е.
мы можем использовать все методы и свойства глобального объекта

Для global тоже самое

Что бы небыло путаницы сделали глобальный объект globalThis(можно вводить и в браузере и в node.js)

метод log - свойство глобального объекта, доступ можно получить:

window.console.log() либо просто console.log()

примеры вызова метода log:
console.log('hello') // в общем случае
window.console.log('hello') // для браузера
global.console.log('hello') // для node.js



                                          МЕТОДЫ (практика  test2.js -8)

метод - это свойство объекта, значение которого функция

методы можно вызывать, потому что функции вызываются( функция выполняет задачу и возвращает значение)


const myCity = {
  city: 'kazan',
  cityGreeting: function () {
    console.log('Greetings!!')
  }
}

myCity.cityGreeting() // 'Greetings!!'

Вызов метода(функции) происходит с использованием круглых скобок



СОКРАЩЕННЫЙ ФОРМАТ ЗАПИСИ МЕТОДОВ

const myCity = {
  city: 'kazan',
  cityGreeting () {                //сокращено без function и без двоеточия
    console.log('Greetings!!')
  }
}

myCity.cityGreeting() // 'Greetings!!'

В этом примере нет ключевого слова function
При записи объектов, в случае, если значение того или иного свойства - функция, можно убирать ключевое 
слово function и ставить круглые скобки после названия свойства не добавляя двоеточие 


Если сравнить методы свойства объектов, то мы знаем, что свойства не содержат функции, а методы
содержат функции как значения, соответственно:
Для доступа к свойствам объекта мы просто используем точечную запись и имя совойства 
myCity.city // получаем доступ к свойству

Если же хотим вызвать метод, то добавляем круглые скобки после названия метода 
myCity.cityGreeting() // вызываем метод cityGreeting, используя круглые скобки



МЕТОДЫ VS СВОЙСТВА ОБЪЕКТОВ

Если сравнить методы и свойств, то свойства не содержат функции, а методы содержат функции 
как значение, соответственно для получения доступа к значениям свойств объекта используем точечную 
запись и имя свойства
 ( пример: myCity.city )
Если мы хотим вызвать метод, то добавляем круглые скобки после названия метода
 ( пример: myCity.cityGreeting() )

------------------------------------------------------------------------------------------

                                          JSON (практика  test2.js -9)

JSON - JavaScript Object Notation - формат обмена данными между компьютерами в интернете


Обычно, когда загружаем любую веб-страницу, эта страница обращается к другим серверам для того, что бы
получить данные для того, что бы показать их нам на экране  -  такими данными могут быть таблицы сти-
лей CSS, картинки, текстовые данные(например список постов или список коментариев) - такие текстовые
данные передаются с серверов используя формат JSON


{
  "userId": 1,
  "id": 1,                                //пример1
  "title": "Test title",
  "status": {
    "completed": false
  }
}
В примере есть набор свойств и эти свойства похожи на свойства в JS объекте, но все свойства находятся
между двойными кавычками - их значения могут быть разных типов.


ПЕРЕДАЧА ДАННЫХ МЕЖДУ КОМПЬЮТЕРАМИ В ФОРМАТЕ JSON

передача происходит в виде строки (пример ниже)

{"userId":1,"id":1,"title":"Test title","status":{"completed":false}}


Конвертация JSON в JS- объект и наоборот

Если сервер присылает нам JSON(набор данных) и нам необходимо распарсить такой JSON и конвертировать 
его в JS - объект для того что бы отобразить например информацию о пользователе на фронтэнд странице,
для это есть встроенный метод, который является методом объекта JSON  и такой метод называется parse
JSON.parse - т.е получив JSON  в формате строки от сервера мы можем передать его как аргумент в 
вызове метода parse и в результате получим JS- объект в формате как в примере1

Если у нас наоборот есть объект JS и мы хотим конвертировать его в JSON, для этого есть метод stringify
JSON.stringify() - метод объекта JSON. Как аргумент в вызове метода (то что в скобках) указываем например переменную, значение
которой это объект JS и в результате получим строку JSON, которую можно передавать на удаленный сервер.

Что бы отследить данные, которы получал комп от удаленных серверов в браузере можно перейти на вкладку(в тулзах) Fetch/XHR, 
выбрать нужный запрос (name) далее выбрать в кладку Response и эти данные можно увидеть в формате строки.
Что бы увидеть объект(распаршеный JSON) нужно перейти на вкладку  Preview (рядом с Response)



                                                МУТАЦИЯ В JS (практика  test2.js -10)

копирование значений примитивных типов

const a = 10
let b = a
b = 30

console.log(a) // 10
console.log(b) // 30

В этом примере есть переменная a и ее значение примитивный тип -  число(10), объявили с помощью const
далее создаем переменную b и оъявляем ее с помощью ключевого слова let, тем самым мы сможем позже присваивать новые значения этой 
переменной.
Далее копируем переменную a в b -  с примитивными типами такое копирование происходит по значению, т.е берется значение, которое 
находилось в переменной a и копируется в переменную b.
Значения примитивных типов сохраняются непосредственно в переменных, потому копирование происходит по значению(copy by value).
После таких опереций, копирования  a в b, мы хотим присвоить новое значение переменной b и после этого в выводе консоли мы
получим 30.
Значение в переменной a  не изменилось, потому что мы скопировали значение переменной a в переменную b.



мутирование ссылочного типа

const person = {
  name: 'slava',
  age: 25
}

person.age = 11  // изменили свойство 
person.isAdult = true // добавили новое свойство

console.log(person.age)  //11
console.log(person.isAdult) // true

в этом премере у нас есть объект с двумя свойствами name и age, их мы можем спокойно измнять благодаря тому, что это ссылочный тип.
(мутация)


мутирование копий ссылочного типа

const person = {
  name: 'slava', 
  age: 25
}

const person2 = person

person2.age = 26
person2.isAdult = true

console.log(person.age)
console.log(person.isAdult)

Здесь мы создаем новую переменную person2 и копируем в нее переменную person(копируем только ссылку на 
  объект)
  Из за того, что копируем ссылку на объект(copy by reference), меняться будет и person и person2, потому что обе переменные
  ссылаются на одно место в памяти
  ЗАПОМНИТЬ ЧТО ПЕРЕМЕННЫЕ person и person2 - ЭТО ССЫЛКИ!!!



КОПИРОВАНИЕ ОБЪЕКТОВ БЕЗ МУТАЦИЙ (практика  test2.js -11)

//пример 1
const person = {
  name: 'slava',
  age: 25
}
                                                      
const person2 = Object.assign({}, person) // в фигурных пустой объект(который создаем),после запятой 
                                          // объект, который копируем
person2.age = 22

console.log(person.age)
console.log(person2.age)


Что бы избежать мутации исходного объекта можно использовать метод assign и этот метод является методом 
объекта Object. Этот объект является свойством глобального объекта.

Object с заглавной буквы потому что это и тип и класс, поэтому PascalCase
Object является прототипом всех объектов в JS

assign - один из методов объекта Object

Здесь мы скопировали не переменную(ссылку), а скопировали объект, в результате создали новый объект

НУЖНО ОБРАТИТЬ ВНИМАНИЕ, ЧТО ЕСЛИ У ИСХОДНОГО ОБЪЕКТА ЕСТЬ ВЛОЖЕННЫЕ ОБЪЕКТЫ, ТО ССЫЛКИ НА НИХ сохраняются
методом assign мы можем избежать мутирования только корневых свойств


// премер 2  
const person = {
  name: 'slava',
  age: 25
}

const person2 = { ...person }

person2.name = 'alex'

console.log(person.name) // 'slava'
console.log(person2.name) // 'alex'

Здесь мы используем оператор три точки(spread - оператор разделения объекта на свойства)
с помощью оператора три точки мы разделяем объект person на свойства и сразу передаем эти свойства в новый 
объект person2

ПРИ КОПИРОВАНИИ С ПОМОЩЬЮ ЭТОГО МЕТОДА ВЛОЖЕННЫЕ ОБЪЕКТЫ БУДУТ ТАКЖЕ МЕНЯТЬСЯ В ОРИГИНАЛЬНОМ ОБЪЕКТЕ,
ТАКЖЕ КАК И С ИСПОЛЬЗОВАНИЕМ МЕТОДА assign


//пример 3 полностью избегаем мутации

const person = {
  name: 'slava',
  age: 25
}

const person2 = JSON.parse(JSON.stringify(person))

person2.name = 'alex'

console.log(person.name) // slava
console.log(person2.name) // alex

В этом варианте используем методы parse и stringify объекта JSON
1. конвертируем объект person в строку - JSON это строка
2. далее берем застроченый объект и передаем как аргумент в вызове метода parse(обратно конвертируем в объект js)

ПРИ КОПИРОВАНИИ С ПОМОЩЬЮ ДВОЙНОЙ КОНВЕРТАЦИИ ССЫЛКИ НЕ СОХРАНЯЮТСЯ ДАЖЕ У ВЛОЖЕННЫХ ОБЪЕКТОВ, СОЗДАЕТСЯ 
НОВЫЙ ОБЪЕКТ С НОВЫМИ ССЫЛКАМИ



                                              ФУНКЦИИ (практика  test2.js -12)
 
 Функция - это блок кода который можно выполнять многократно                                             

let a = 5
let b = 3

let c

c = a + b
console.log(c)

let a = 8
let b = 12

c = a + b
console.log(c)

рекомендуется  избегать повторение блоков кода, поэтому  пример выше не корректен(но работает)

что бы избежать повторения, можно создать функцию

let a = 5
let b = 13

function sum(a, b) {
 const c = a + b
 console.log(c)
}

sum(a, b)

внутри функции выводим результат в консоль.
так же можно вернуть значение c внутри функции и вызвать метод log вне функции

--------------------------------------------------------------------------------------
Функция может быть:
1. именованной
2. присвоена переменной
3. анонимной
4. аргументом при вызове другой функции (колбэк функция)
5. значением свойства объекта

Функция в JS - это объект, и соответственно у функции как и любого объекта есть свойства

function myFn(a, b) {
  let c
  a = a + 1
  c = a + b
  return c  // возврат переменной c - иначе возврат результата. после функция прекращает выполнение 
            //дальнейших инструкций
}

myFn(10, 3) // вызов функции с аргументами ( в консоль console.log(myFn(10, 3)) )

с помощью console.dir можно просмотреть структуру объекта(функции) в консоли

структура функции:
-ключевое слово function
-имя функции
-параметры функции в круглых скобках - воспринимаем как переменные действующие только внутри функции
-тело между фигурными скобками

ЕСЛИ ФУНКЦИЯ НЕ ИМЕЕТ ИНСТРУКЦИИ return, ТО ОНА ВОЗВРАЩАЕТ ЗНАЧЕНИЕ undefined


результат вызова функции можно присвоить переменной и вывести переменную в консоль(пример ниже)

function myFn(a, b) {
  let c
  a = a + 1
  c = a + b
  return c  
}
const sum = myFn(2, 6)
console.log(sum)


ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ (практика  test2.js -13)

const personOne = {
  name: 'slava',
  age: 21
}                                      //пример

function increasePersonAge(person) {
  person.age += 1
  return person
}

increasePersoneAge(personOne)
console.log(personOne.age)  // 22



в примере в качестве аргумента функции мы передаем объект 
в вызове функции increasePersoneAge, personeOne - это объект
функция increasePersoneAge объявлена выше, в этой функции есть параметр person и внутри этой функции мы
меняем свойства этого параметра. += это оператор, который увеличивает значение свойства или другой переменной
на единицу, и в итоге мы возвращаем person. Мы предполагаем что person это объект, который будет 
передаваться в функцию при вызове такой функции.
Мы передаем в вызове  функции аргумент personeOne, значение этой переменной объект(ссылка на объект), 
тем самым переменная personeOne и person будут ссылаться на один объект

Внутри функции мы мутируем внешний объект. - НЕ РЕКОМЕНДУЕТСЯ

----------------------------------------------------------------------------

ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ БЕЗ МУТАЦИИ (практика  test2.js -14)

const personOne = {
  name: 'slava',
  age: 25
}

function increasePersonAge(person) {
  const updatePerson = Object.assign({}, person)
  updatePerson.age ++
  return updatePerson
}

const updatePersonOne = increasePersonAge(personOne)
console.log(personOne)
console.log(updatePersonOne)



                                      КОЛБЭК ФУНКЦИИ  (практика  test2.js -15)     
                                      
 function anotherFunction() {
  // Действия...
 }              
 
 function fnWithCallback(callbackFunction) {
  callbackFunction()
 }

 fnWithCallback(anotherFunction)


 Когда функция вызывает внутри себя другую функцию - это КОЛБЭК ФУНКЦИЯ

 пример

 function printMyName = {
  console.log('slava')
 }

setTimeout(printMyName, 1000)

Функция setTimeout встроена в JS, она доступна по умолчанию, как один из методов глобального объекта.

1000 - время в миллисекундах



ПРАВИЛА РАБОТЫ С ФУНКЦИЯМИ

1. Называть функции исходя из выполняемых задач
2. Одна функция должна выполнять одну задачу
3. Не рекомендуется изменять внешние относительно функции переменные



                                          ОБЛАСТЬ ВИДИМОСТИ

Область видимости - определяет границы действия переменной

если в локальной области видимости не находится нужная переменная, она берется из глобальной области видимости

пример

let a
let b

function myFn() {
  let b
  a = true
  b = 10
  console.log(b) // 10
}

myFn()

console.log(a) // true
console.log(b) // undefined

a и b объявлены в глобальной области видимости
переменная b объявленная внутри функции - локальная переменная, которая доступна только внутри функции(названия переменных
  b, объявленных в глобальной области видимости и локальной области видимости совпадают)



ЦЕПОЧКА ОБЛАСТЕЙ ВИДИМОСТИ

const a = 5

function myFn() {
  function innerFn() {
    console.log(a) // 5
  }
  innerFn()
}

myFn()

При попытке получения доступа к переменной a внутри функции myFn она возьмется из глобальной области видимости
В глобальной области видимости мы не сможем получить доступ к функиции innerFn, потому что она объявлена внутри другой функции,
а это локальная область видимости


ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ

- Глобальная область видимости
- Область видимости функции
- Область видимости блока - переменные объявленные с помощью let и const внутри блока имеют область видимости, ограниченную
    этим блоком. Блок - любой код, находящийся между фигурных скобок.

    Блоки используются не только в функциях, но и в конструкциях типа if, else if либо в различных for циклах


    Пример

    function myFn() {
      a = true
      console.log(a) // true
    }

    myFn()

    console.log(a)

    В этом примере объявлена функция myFn и внутри этой функции мы присваиваем значение true переменной a, но такой переменной нет 
    ни в области видимости функции, ни в глобальной области видимости(не объявлена)
    Такой код не верный, но он выполнится, переменная a  будет объявлена автоматически в глобальной области видимости


    ПРАВИЛА РАБОТЫ С ПЕРЕМЕННЫМИ

    1. Все переменные объявлять перед их использованием
    2. Стараться использовать const везде, где это возможность
    3. Внутри функции не изменять переменные с внешних областей видимости(объявлять те переменные, которые нужны в рамках функции)

    Для того что бы автоматически не создавались переменные используется строгий режим strict mode

    strict mode - это инструкция интерпритатору js анализировать код более пристально

    что бы включить строгий режим, нужно напечатать 'use strict' вначале программы

    пример

    'use strict' - эта строка должна быть в глобальной области видимости или в области видимости функции

    function myFn() {
      a = true // Uncaught ReferenceError: a is not defined at myFn
      console.log(a)
    }

    myFn()
    console.log(a)


                                                ОПЕРАТОРЫ

Оператор - это встроенная в js функция (внутренняя функция js) и когда мы используем оператор, мы запускаем встроенную ту или
    иную функцию и эта функция выполняет определенные действия и возвращает результат, как любая функция


    Арифметические операторы

    +  сложение
    - вычетание
    * умножение
    / деление

-----------------------------------
    Операторы сравнения 

    === равно
    !== неравно
    <=  меньше либо равно
    >=  больше либо равно
------------------------------------
    Логические операторы

    !   не
    &&  и
    ||  или

    ---------------------------------

    = оператор присваивания(это не оператор сравнения)



    Текстовые операторы

    typeof      - проверка типа того или иного значения
    instanceof  - проверка принадлежности объекта к тому или иному классу
    new         - 
    delete      - удаление свойства в объекте


    Пример a, b   -  запятая тоже оператор, с ее помощью можно объявить несколько переменных в одной строке

    a = 10  // a - операнд ,  10 - операнд
    b = a

    let c = a + b
    
    console.log(c) // 20

здесь а и 10 - это операнды

  

УНАРНЫЕ ОПЕРАТОРЫ - всегда один операнд(аргумент)

a++                 увеличение значения переменной на 1
+a                  конвертация например строки в число
delete obj.a        удаление(с путем свойства объекта) 
typeof a            можно узнать тип переменной
new Object()        с помощью оператора new можно создать новый экземпляр объекта


БИНАРНЫЕ ОПЕРАТОРЫ - всегда два операнда(аргумента)

a = 5               оператор присваивания     
a + b               
a += 5              увеличение значения на 5 и присвоение
a === b             оператор сравнения(сравнивает тип и значение)
a && b              


---------------------------------------------------------------------------

ФОРМЫ ЗАПИСИ ОПЕРАТОРОВ И ОПЕРАНДОВ

Инфиксная запись - оператор между операндами

a = true
a + b 
и т.д.


префиксная запись - оператор перед операндом

++a
delete obj.a
typeof a 
и т.д.


постфиксная запись - оператор после операнда

a++
a--
myFunction() // скобки тоже оператор


-----------------------------------------------------------------------

ЛОГИЧЕСКИ ОПЕРАТОРЫ

!  - НЕ   // возвращает либо true либо false
&& - И   // бинарный, возарвщает значение одного из операндов
|| - ИЛИ // бинарный, возарвщает значение одного из операндов




Оператор ! чаще всего используется в условных инструкциях

!10         // false
!0          // true
!'abc'      // false
!''         // true
!true       // false
!undefined  // true


Отрицание отрицания !!

!!10        //true
!!0         //false
!!'abc'     //true
!!''        //false
!!true      //true
!!undefined //false



Операторы && и || являются операторами короткого замыкания (short circuit)

оператор &&

пример:
выражение 1 && выражение 2 

каждый из операндов - выражение, любое выражение возвращает значение
в данном примере, если выражение 1 - ложно(например пустая строка), выражение 2 игнорируется и возвращается результат 
выражения 1, как результат всего выражения

 ОПЕРАТОР && (И) ТРЕБУЕТ ПРАВДИВОСТИ ОБОИХ ОПЕРАНДОВ
ОПЕРАТОР И НАЗЫВАЕТСЯ ОПЕРАТОРОМ КОРОТКОГО ЗАМЫКАНИЯ, ПОТОМУ ЧТО МЫ ИЩЕМ ПЕРВОЕ ЛОЖНОЕ ЗНАЧЕНИЕ



Оператор || 

пример:
выражение 1 || выражение 2 

если выражение 1 истинно, выражение 2 игнорируется, возвращается результат выражения 1



ОПЕРАТОР РАЗДЕЛЕНИЯ ОБЪЕКТА НА СВОЙСТВА ... (spread) - (практика  test2.js -16) 


пример:

const button = {
  width: 200,
  text: 'Buy'
}

const redButton = {
  ...button,
  color: 'red'
}

console.table(redButton)


В объекте button 2 свойства 
Допустим мы хотим создать новый объект, используя этот объект как основу и добавить новое свойство. Это можно легко сделать
используя оператор разделения объекта на свойства: Мы создаем новую переменную(объявляем ее) redButton и допустим к свойствам 
width и text хотим добавить еще одно свойство color, которое будет указывать на цвет кнопки, это мы можем сделать используя
оператор разделения на свойства


пример 2

const buttonInfo = {
  text: 'buy'
}

const buttonStyle = {
  width: 200,
  height: 100,
  color: 'red'
}

const button = {
  ...buttonInfo,
  ...buttonStyle
}

console.table(button)

можно собрать один общий объект из двух других(влияет порядок свойств, например цвет может перезаписаться, если свойство дублируется)

МУТАЦИЯ ИСХОДНЫХ ОБЪЕКТОВ НЕ ПРОИЗОЙДЕТ, ЕСЛИ НЕТ ВЛОЖЕННОСТИ



                                            КОНКАТЕНАЦИЯ(СОЕДИНЕНИЕ) СТРОК - (практика  test2.js -17)


Опреатор + для конкатенации строк

'Hello' + 'World'  - если не будет пробела после слова, слова сольются в одно // 'HelloWorld'
'Hello ' + 'World' // 'Hello World'

Переменные в конкатенации строк 

const hello = 'Hello'
const world = 'World'

const greeting = hello + ' ' + world

мы создали две переменные hello  и world и присвоили им значения и потом создали новую переменную greeting и в качестве значения 
присвоили выражение сложения двух переменных с добавлением строки-пробела(в одинарных кавычках)

Такая конкатенация не удобна, потому что нужно следить, где нужно ставить пробел и другие знаки припенания и если переменных много, 
которые мы хотим соединить вместе,  то такое выражение может оказаться очень длинным, потому в js есть функция - шаблонные строки


ШАБЛОННЫЕ СТРОКИ (TEMPLATE STRING LITERAL)

const hello = 'Hello'
const world = 'world'

const greeting = `${hello} ${world}`

обратить внимание, что тут используются обратные кавычка!!!

Используя такой синтаксис, мы можем внутри него использовать любые выражения js и для того, что бы получить результат какого
либо выражения, мы должны поместить выражения в фигурные скобки и поставить перед ними знака доллара $



                                                  ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ

Разница между объявленной функцией и функциональным выражением 

пример объявленной функиции

function myFn(a, b) {
  let c
  a = a + 1
  c = a + b
  return c 
}


пример функционального выражения

function(a, b) {
  let c 
  a = a + 1
  c = a + b
  return c
}

                  разница в том что у объявленной функции есть имя, а у функционального выражения его нет 


ПРИСВАИВАНИЕ ФУНКЦИОНАЛЬНОГО ВЫРАЖЕНИЯ ПЕРЕМЕННОЙ - (практика  test2.js -18)

const myFunction = function(a, b) {
  let c
  a = a + 1
  c = a + b
  return c
}

myFunction(5, 3)  // 9



                                                  СТРЕЛОЧНЫЕ ФУНКЦИИ - (практика  test2.js -19)
                                                
 В стрелочных функциях нет ключевого слова function  

 (a, b) => {
  let c
  a = a + 1
  c = a + b
  return c
 }

 У стрелочной функции нет имени, она начинается сразу же с параметров

 стрелочная функция - это выражение
 стрелочная функция всегда анонимна

 имя стрелочной функции можно дать путем присваивания переменной

 const myFunction = (a, b) => {
  let c
  a = a + 1
  c = a + b
  return c
 }

 console.log(myFunction(2, 4))

 рекомендуется использовать этот способ, так как const мы не сможем случайно поменять


 СТРЕЛОЧНАЯ ФУНКЦИЯ В ВЫЗОВЕ ДРУГОЙ ФУНКЦИИ

 setTimeout(() => {
  console.log('отложенной сообщение')
 }, 1000)




                                                          ЗНАЧЕНИЯ ПАРАМЕТРОВ ФУНКЦИИ ПО УМОЛЧАНИЮ - (практика  test2.js -20)

 function multByFactor(value, multiplier = 1) {
  return value * multiplier
 }

 multByFactor(10, 2) // 20
 multByFactor(5) // 5

 если при вызове функции указать один аргумент, во второй передается значение по умолчанию

----------------------------------------------------------------------------------------------

const newPost = (post, addedAt = Date()) => ({
  ...post,
  addedAt,
})                                                // другие варианты в практике(более понятные)

const firstPost = {
  id: 1,
  author: 'slava',
}

newPost(firstPost)





                                                         ОБРАБОТКА ОШИБОК - (практика  test2.js -21)

 const fnWithError = () => {
  throw new Error('Some Error')
 }

 fnWithError() // вызов фунции

 console.log('Continue...')

 В этом коде у нас есть функция и она присвоена переменной. Внутри стрелочной функции есть инструкция (throw new Error) - 
   с помощью такой инструкции мы можем сгенерировать какую то ошибку в js.
Выполнение кода остановится в момент вызова функции.

РЕШЕНИЕ ПРОБЛЕМЫ TRY/CATCH

TRY/CATCH - Специальный синтаксис, состоящий из двух блоков кода

try{
  // выполнение блока кода
}

cache(error) {
  // этот блок кода выполняется в случае возникновения ошибок в блоке try
}

в первый блок мы помещаем код в котором вероятно возникновение ошибок, если ошибка возникает в этом блоке, будет выполняться код, 
который расположен во втором блоке

пример:

const fnWithError = () => {
  throw new Error('Some error')
}

try {
  fnWithError()
} catch(error){
console.error(error)
console.log(error.message)
}

console.log('Continue...')

В этом примере присутствует таже самая функция и внутри этой функции генерируется ошибка. 
Теперь вызов функиции мы оборачиваем в try/catch блок 

Ошибки удобно печатать в консоль с помощью console.error метода, ошибка будет выведена красным цветом(в браузере)

Если мы поймали ошибку в try/catch блок, то выполнение кода продолжится.



                                                    ИНСТРУКЦИИ 


  В JS есть выражения, они всегда возвращают значение

  В js есть инструкция, пример инструкции - это объявление переменной с помощью ключевого слова let (let a)

  В js есть выржение-инструкция, выражение может быть инструкцией(exspression statement)


  ИНСТРУКЦИЯ ВЫПОЛНЯЕТ ОПРЕДЕЛЕННОЕ ДЕЙСТВИЕ - в этот отличие инструкции от выражения

  примеры инструкиций:
  
  let a; - такая инструкция выполняет действие - это создание переменной и присваивание ей какого то значения(здесь не опреденлено)

  const b = 5;

  if (a > b) {
    console.log('a is larger');
  }

  for (let i = 0; i++; i < 5) {
    console.log(i);
  }

  каждую инструкцию следует завершать точкой с запятой и следует разделять инструкуции пустой строкой(посл блока не надо)

-----------------------------------------------------------------------------------------------------------------------

выражение-инструкция

'abc';

a = a + 3;

c = a + b;

d = 'Good ' + 'Evening';

myFunction(c, d);

console.log('Hey');


ИНСТРУКЦИЯ НЕ МОЖЕТ БЫТЬ ТРАНСФОРМИРОВАНА В ВЫРАЖЕНИЕ

КАК ОТЛИЧИТЬ ВЫРАЖЕНИЕ ОТ ИНСТРУКЦИИ?
выражения могут быть использованы как аргументы в вызовах функций(инструкции не могут быть использованы как аргументы в вызовах
 функции)


ИНСТРУКЦИЯ ИЛИ ВЫРАЖЕНИЕ?

function myFn(a) {
  console.log(a);
}

const b = true;
let c = 10;

myFn(2+3) // 5
myFn(b) // true
myFn(c = c + 1) // 11
myFn(c = c + 1;) // не коректно, инструкция не может быть использована в качестве аргумента
myFn(let d) // не коректно, инструкция не может быть использована в качестве аргумента




                                                      МАССИВЫ (практика  test2.js -22)

  МАССИВ - ЭТО ОБЪЕКТ С ЦИФРОВЫМИ ИМЕНАМИ СВОЙСТВ

  Формат записи массивов

const myArray = [1, 2, 3]         - прототип массив
console.log(myArray) // [1, 2, 3]

const myArray2 = new Array(1, 2, 3) - прототип объект
console.log(myArray2) // [1, 2, 3]

в один массив можно добавлять элементы разных типов( строки, числа, булевые значения, объекты, другие массивы)

с помощью ключевого слова new можно создавать новые экземпляры классов

-----------------------------------------------------------------------------
                  структура массивов

                  (3) [1, 2, 3]
                    0: 1  // 0 - ключ, 1 - значение
                    1: 2
                    2: 3
                    length: 3 - можно прочитать свойство с помощью точечной записи myArray.length, length создается автоматически
                    __proto__: Array(0)
------------------------------------------------------------------------------

прототипы влияют на то, какие методы доступны для объектов и массивов 

поле length - автоматически обновляется при изменении количества элементов массива

если мы создадим массив как объект и добавим самостоятельно свойство length, то обновляться оно не будет

---------------------------------------------------------------------------------

ЧТЕНИЕ ЗНАЧЕНИЙ МАССИВА

const myArray = [1, true, 'a']
console.log(myArray) // [1, true, 'a']

console.log(myArray[0]) // 1
console.log(myArray[1]) // true

console.log(myArray.length) // 3

читать элементы массива можно по индексу, через квадратные скобки

если самостоятельно поменять свойство length то у массива появятся дополнительные пустые элементы(myArray.length = 7) и выглядеть
он будет так [ 1, true, 'a', <4 empty items> ] - ТАК ДЕЛАТЬ НЕ НУЖНО

ПОРЯДОУК ЭЛЕМЕНТОВ В МАССИВЕ ВАЖЕН (в объекте не важен)

-----------------------------------------------------------------------

ДЛИНА МАССИВА
как добавлять новые элементы в массив

const myArray = [1, 2, 3, 4]  
console.log(myArray)             // [1, 2, 3, 4]
console.log(myArray.length)      // 4

myArray[2] = 'abc'

console.log(myArray) // [1, 2, 'abc', 4]
console.log(myArray.[2]) // 'abc'

myArray[4] = true

console.log(myArray) // [1, 2, 'abc', 4, true]
console.log(myArray.length) // 5


если добавлять новый элемент массива под занятым индексом - элемент перезапишется

добавлять новые элементы выше указанным способом не удобно, для этого есть специальные методы массива

------------------------------------------------------------------------------------------

МЕТОДЫ МАССИВОВ - иначе функции высшего порядка в массивах, либо функциями прототипов, либо методами прототипов

push
pop
shift
unshift
forEach
map

любой метод массива можно вызывать, используя точечную запись после названия переменной, которую содержит массив
если в браузере написать myArray и поставить точку, то можно увидеть весь список свойств и методов, котороу доступны для использования
в переменной my Array

----------------------------------------------------------------------------------------------
PUSH - добавляет новый элемент в конец массива, используя точечную запись

const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]

myArray.push(4)

console.log(myArray) // [1, 2, 3, 4]

myArray.push(true)

console.log(myArray) // [1, 2, 3, 4, true]

----------------------------------------------------------------------------------------------
POP - удаляем элемент с конца массива, указывается без аргументова, потому что просто удаляет последний элемент массива

const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]

myArray.pop()

console.log(myArray) // [1, 2]

const removedElement = myArray.pop() // метод pop также возвращает удаленный элемент, мы можем присвоить результат вызова метода 
                                          //  переменной и в после можем посмотреть какой элемент мы удалили

console.log(myArray) // [1]
console.log(removedElement) // 2

----------------------------------------------------------------------------------------------
UNSHIFT - добавляем элемент в начало массива (редкий метод)

const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]

myArray.unshift(true)

console.log(myArray) // [true, 1, 2, 3]

myArray.unshift('abc')

console.log(myArray) // ['abc', true, 1, 2, 3]

------------------------------------------------------------------------------------------------
SHIFT  - удаляет первый элемент массива

const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]

myArray.shift()

console.log(myArray) // [2, 3]

const removedElement = myArray.shift() // метод shift также возвращает удаленный элемент, мы можем присвоить результат вызова метода 
//  переменной и в после можем посмотреть какой элемент мы удалили

console.log(myArray) // [3]
console.log(removedElement)




                                          forEach (практика  test2.js -23)

const myArray = [1, 2, 3]
console.log(myArray) // [ 1 2 3 ]

myArray.forEach(el => console.log(el * 2))

console.log(myArray) // массив не изменился

В этом методе есть аргумент, который является функцией(стрелочная функция)

круглые скобки у параметра упущены, потому что у функции один параметр, но можно и поставить

данный метод переберает все элементы массива и для каждого элемента массива метод forEach будет вызывать колбэк функцию и а этот колбэк в качестве
значения для параметра el, будет передаваться значение определенного элемента массива

метод forEach не меняет оригинальный массив


метод forEach возвращает undefined, потому что основная задача это перебор элементов массива и выполнение определенных действий с каждым элементом
возвращать forEach ничего не должен



                                                      map (практика  test2.js -24)


const myArray = [1, 2, 3]
console.log(myArray) // [ 1 2 3 ]

const newArray = myArray.map(el => el * 3)

console.log(myArray) // [1 2 3] массив не изменился
console.log(newArray) // [3 6 9] новый измененный массив

метод map ожидает колбэк в качестве аргумента и возвращает новый массив после перебора всех элементов 
нужно создавать новую переменную при вызове данного метода 

НЕЯВНО ВОЗВРАЩАТЬ РЕЗУЛЬТАТ МОГУТ ТОЛЬКО СТРЕЛОЧНЫЕ ФУНКЦИИ!!! функциональные выражения и именованные функции - не могут





                                                  ДЕСТРУКТУРИЗАЦИЯ (практика  test2.js -25, 26)

    ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ(практика  test2.js -25)

   предположим, что у нас есть объект и мы хотим присвоить некоторые значения из свойств этого объекта новым переменным    
   
   const userProfile = { 
    name: 'slava',
    commentsQty: 23,
    hasSignedAgreement: false,
   }

   const {name, commentsQty } = userProfile
   const {hasSignedAgreement} = userProfile
   
   console.log(name) // slava
   console.log(commentsQty) // 23

   у нас есть объект со свойствами, предположим что мы хотим создать новые переменные, которые будут называться как свойства 
   объекта userProfile и присвоить им соответствующие значения изходя из свойств объекта userProfile.

   Использая такой синтаксис говорим интерпритатору, что мы хотим взять из объекта userProfile значения свойсты name и commentsQty
   создать новые переменные с такими же именами и присвоить им значения соответствующих свойств в этом объекте


   ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ (практика  test2.js - 26)

   const fruits = ['apple', 'banana']

   const [fruitsOne, fruitsTwo] = fruits; // указываем новые переменные в нужном порядке

   console.log(fruitsOne, fruitsTwo) 

   в массивах порядок элементов важен


   ДЕСТРУКТУРИЗАЦИЯ В функциях (практика  test2.js - 27)

   const userProfile = {
    name: 'slava',
    commentsQty: 23,
    hasSignedAgreement: false,
   }

   const userInfo = ({ name, commentsQty }) => {
    if (!commentsQty) {
      return `User ${name} has no commenst`  
    }
    return `User ${name} has ${commentsQty} comments`
   }

   userInfo(userProfile) 




                                                        // УСЛОВНЫЕ ИНСТРУКЦИИ (практика  test2.js - 28)

  В js есть такие условные инструкции как:
   if
   if ... else
   if ... else ... if
   switch
   тернарный оператор - используется в выражении, аыражение возвращает результат 


   if (Условие) {
    // Блок код, выполняемый однократно, если условие правдиво
   }
 задача инструкции if привести условие к булевому значению, если условие правдиво, мы выполняем блок кода

 пример:

 let val = 10
 
 if ( val > 5 ) {
  val += 20
 }

 console.log(val) // 30

 пример 2:

 const person = {
  age: 20 
 }

 if (!person.name) {
  console.log('Имя не указано')
  // другие действия в случае, если свайства name у объкта person нет
 }
   
-----------------------------------------------------------------------------------------------------------

if ... else

if(условие) {
  //блок кода, выполняемый однократно, если условие правдиво
} else {
  //блок кода, выполняемый однократно, если условие ложно
}


пример:

let val = 10

if (val < 5) {
  val += 20
} else {
  val -=20
}
  console.log(val) // -10

  ------------------------------------------------------------------------------------------------------

  if...else...if

  if ( условие1 ) {
    // блок кода, выполняемый однократно, если условие1 правдиво
  } else if (условие2 ) {
    //блок кода, выполняемый рлнократно, если условие2 правдиво 
  } else {
    // блок кода, выполняемый однократно, если предыдущие уловия ложны
  }
       
  в этом случае мы можем комбинировать несколько инструкций else и if 

  для читабельности можно использовать 

  if ( условие1 ) {
    // блок кода, выполняемый однократно, если условие1 правдиво
  } 

  if ( условие2 ) {
    // блок кода, выполняемый однократно, если условие2 правдиво
  } 

  if ( условие3 ) {
    // блок кода, выполняемый однократно, если условие3 правдиво
  } 

  пример:

  const age = 25

  if (age> 18) {
    console.log('is adult')
  } else if (age >= 12) {
    console.log('is teenager')
  } else {
    console.log('is child')
  }

  ----------------------------------------------------------------------------------------------

  ИСПОЛЬЗОВАНИЕ IF В функциях

  const sumPositiveNumber = (a, b) => {
    if (typeof a !=='number' || typeof b !=='number') {  // в одинарных кавычках указываем тип переменной
      return 'One of the argument is not a number'
    } 
    if (a <= 0 || b <= 0) {
      return 'Numbers are not positive'
    }
    return a + b
  }

  -------------------------------------------------------------------------------------------------

  switch - альтернатива использованию инструкции if else if, когда у нас много разных условий

синтаксис инструкции

switch (выражение) {
  case A:
    // действие если выражение === A
    break // выход из условной инструкции switch
  case B: 
  // действие, если выражение === B
  break
  default:
    // действия по умолчанию (в данном случае, если выражение не равно А и не равно В- равносильно  завершающему блоку else)
}

пример

const month = 2

switch(month) {
  case 12:
    console.log('декабь')
    break
  case 1:
    console.log('Январь')
    break
  case 2: 
  console.log('Февраль')
    break
  default:
    console.log('это не зимний месяц')      
}



                                                        ТЕРНАРНЫЙ ОПЕРАТОР(практика  test2.js - 29) 

У тернарного оператора три операнда

конструкция с тернарным оператором - ВЫРАЖЕНИЕ - возвращает значение

например тернарный оператор можно использовать для того, что бы присвоить значение переменной 


СИНТАКСИС ТЕРНАРНОГО ОПЕРАТОРА 

Условие ? Выражение 1 : Выражение 2     - если условие правдиво, то возвращается результат выражения 1, если условие ложно, то 
возвращается результат выражения 2

пример

const value = 11

value
? console.log('условие истино')
: console.log('условие ложно')


пример 2

const value1 = 11
const value2 = 25

value1 && value2 - оба выражения правдивы (не 0 не фолс не андефайнд)
  ? myFunction1(value1, value2)  -  т.к оба выражения правдивы, вызывается эта функция
  : myFunction() - если бы хотя бы одно из выражений было ложно, вызывалась бы эта функция


  пример 3
  
  let value = 11
  console.log(value >= 0 ? value: -value) //11

  value = -5
  const res = value >= 0 ? value: - value
  console.log(res) // 5

       

                                                      ЦИКЛЫ (практика  test2.js - 30) 

  пример 1
 let i = 0
 console.log(i)
 i++ 
 console.log(i)
 i++ 
 console.log(i)                   ТАК НЕ ДЕЛАЮТ
 i++ 
 console.log(i)
 i++ 
 console.log(i)
 i++ 

 Циклы JavaScript обеспечивают многократное выполнение повторяющихся вычислений. Они оптимизируют процесс написания кода,выполняя 
 одну и ту же инструкцию или блок инструкций, образующих тело цикла, заданное число раз (используя переменную-счётчик) или пока
  заданное условие истинно


  пример 2 перебор всех элементов массива без цикла

  const myArray = [true, 'abc', 10]

  console.log(myArray[0])
  console.log(myArray[1])
  console.log(myArray[2])


  пример 3 перебор всех свойств объекта

  const myObject = {
    x: 10,
    y: true,
    z: 'abc'
  }

  console.log(myObject.x)
  console.log(myObject.y)
  console.log(myObject.z)

  

  ДЛЯ УДОБСТВА ПЕРЕБОРА ЭЛЕМЕНТОВ МАССИВА ИЛИ ПЕРЕБОРА СВОЙСТВ ОБЪЕКТА ИСПОЛЬЗУЮТ ЦИКЛЫ


  ТИПЫ ЦИКЛОВ
  
  for
  for... in...
  while
  do... while
  for... of...

  ----------------------------------------------------------------------------------------------------------
 
  ЦИКЛ for

  все циклы это инструкуции

for (Начальная инструкция; условие; итерационное действие) {

  //блок кода, выполняемый на каждой итерации

}

for (let i = 0; i < 5; i++) {
  console.log(i)
}

цикл for можно использовать для перебора массивов, но не рекомендуется ( использовать forEach, map, reduce)


const myArray = ['first', 'second', 'third']
for (i =0; myArray.length > i; i++) {                  // ТАК НИНАДА (i -это индекс)
  console.log(myArray[i])
}
здесь мы хотим перебрать все элементы массива и вывести их в консоль


const myArray = ['first', 'second', 'third']
myArray.forEach(element, index){                       // ТАК НАДА
  console.log(index, element)
}

используя forEach мы можем получать доступ непосредственно к элементам массива и если хотим то и к индексу определенного элемента

forEach - создан для того что бы просто перебирать элементы массива (возвращат undefined - нет смысла присваивать переменной)

-------------------------------------------------------------------------------------------------------------------

ЦИКЛ while 

позволяет выполнять блок кода пока условие правдиво(блок инструкций может быть ни разу не выполнен, при ложном условии)

while (условие) {
  // блок кода, выполняемый на каждой итерации
}

если условие будет всегда правдиво, то из цикла никогда не выйдем( такго необходимо избегать)

let i = 0;

while (i < u) {
  console.log(i)
  i++
}

получается что в цикле for мы в одной из начальных инструкций указываем как изменять переменную, которая влияет на количество циклов
здесь же мы внутри цикла сами должны контролировать изменение условия

----------------------------------------------------------------------------------------------------------------

ЦИКЛ do while 

этот цикл выполнится как минимум 1 раз, потому что такая инструкция начинается с ключевого слова do потом идет блок кода, который 
выполняется на каждой итерации и дальше после блока уже идет while и условие

let i = 10;

do {
  console.log(i)
  i++
} while (i < 5)

i изначально больше пяти - условие ложно и цикл выполнять не должен, но так как это do while цикл выполнится один раз

-----------------------------------------------------------------------------------------------------------------------

ЦИКЛ for in 

for (key in Object) {
  // Действие с каждым свойством объекта 
  // значение свойства - Object[key]
}

ключевое слово for далее в скобках стоит вторая часть инструкции key - название переменной, Object - объект и с помомощью этой 
инструкции можно выполнять разные действия с каждым свойством объекта (key - название свойства в объекте), используя такой цикл
мы можем перебрать все свойства объекта.
получить значение к свойству объекта, мы можем использовать квадратные скобки, потому что key - это переменная в этом блоке и
key будет меняться и содержать название разных свойств объекта


const user1 = {
  name: 'slava',
  id: 22,
  sign: true,                          //перебираем все свойства объекта и выводим в консоль
}

for (key in user1) {
  console.log(key, user1[key] )
}


forEach для перебора свойств объекта 

const user1 = {
  name: 'slava',
  id: 22,
  sign: true, 
}
Object.keys(user1).forEach(key => {
  console.log(key, user1[key])
})

с помощью вызова метода keys, который я вляется методом объекта, можно получить все ключи определенного объекта в виде массива

конструкция Object.keys(), с помощью этого метода можно получить все ключи определенного объекта  в виде массива 

Object.keys(user1)  // [ 'name', 'id', 'sign' ]
а дальше с помощью метода forEach мы можем перебрать элементы этого массива 


Кроме этого можно переберать сразу значения свойств объекта

const user1 = {
  name: 'slava',
  id: 22,
  sign: true, 
}
Object.values(user1).forEach(key => {
  console.log(key, user1[key])
})


Object.values(user1) - на выходе даст массив с тремя значениями, так как это массив, мжно перебрать методом forEach

--------------------------------------------------------------------------------------------------------------------

ЦИКЛ for of

for (Element of Iterable) {
  // действия с определенным  элементом
}

Iterable- это любое значение или переменная, которая содержит значение, по которому можно итерироваться(перебирать)




                                                    МОДУЛИ

Для чего нужны модули?
 Ранее в курсе писали код в отдельном файле или в консоли браузера, все это делалось что бы изусить функции js. 
 В реальной жизни проект состоит из огромного количества разных файлов и папок и необходимо каким то образом связать разные части
 приложения воедино - это делается с помощью модулей т.е МОДУЛИ ПОЗВОЛЯЮТ СТРУКТУРИРОВАТЬ КОД.  

 Каждый файл содережит часть общего функционала приложения.

 Отдельные функции можно экспортировать из одного файла и импортировать в другие файлы

 Модули позволяют избегать дублирования блоков кода т.е мы можем вынести какую то функцию в отдельный модуль, а далее использовать 
 эту функцию во многих других файлах

 синтаксис:

  EXPORT/IMPORT СИНТАКСИС ПОЯВИЛСЯ В ES6

  moduleOne.js          moduleTwo.js
  export ...            import ...


  каждый файл в нашем приложении является отдельным модулем и в каждом модуле мы можем определять функции, классы, переменные, 
выполнять различные операции и потом, используя слово export экспортировать часть переменных из такого модуля и оптом в других
файлах(модулях) испоьзуя ключевое слово import мы можем импортировать определенные переменные, например определенные функиции из
других модулей и потом вызывать их там где мы их импортировали

пример:

        moduleOne.js              |         moduleTwo.js  
                                  |
 const myName = () => {           |   import printMyName from './modileOne.js'  
  console.log('slava')            |
 }                                |   printMyName = () // slava
                                  |
 export default myName            |


 у нас есть два файла moduleOne.js и moduleTwo.js. В  первом моделе у нас определена функция myName и потом мы эту функцию 
 экспортируем из moduleOne и далее мы импортируем ее в moduleTwo


 вариант импорта/экспорта с измененнием имени переменной(функции) и не дефолтом(добавить фигурные скобки)


        moduleOne.js             |             moduleTwo.js  
                                 |
 const userProfile = {           |  
  userName: 'slava',             |  import { UserName as printUserName } from './moduleOne.mjs';
  age: 26,                       |
  id: 1,                         |  printUserName()
}                                |
                                 |
const UserName = () => {         |
  console.log(userProfile)       |
}                                |
                                 |
export {UserName}                |



ПРАВИЛА РАБОТЫ С МОДУЛЯМИ

1. Модули должны быть одноцелевыми
2. Распологать все экспорт инструкции внизу файла
3. Распологать все импорт инструкции вверху файла
4. По возможности использовать дефолт






                                                                    КЛАССЫ И ПРОТОТИПЫ (практика  test2.js - 31) 

  синтаксис классов появился в ES6 

  class...

  классов до ES6 не было, потому что js не является объектно ориентированным языком программирования и наследования, экземпляры, все это существовало
  в js благодаря объектам и функциям т.е. экземпляры объектов создавались с помощью функций 

  Для того, что бы сделать js похожим на объектно ориентированный язык ввели синтаксис классов и с помощью классов мы можем создавать шаблоны, либо
  заготовки для объектов и потом на основании этих заготовок, создавать экземпляры объектов

  Классы позволяют создавать прототипы для объектов
  С одной заготовки можно создать много экземпляров объектов и все экземпляры будут независимы друг от друга и аждый экземпляр может иметь свои 
  собственные свойства и методы, которые привязаны только к конкретному экземпляру.

  Также экземпляры наследуют свойства и методы прототипов, т.е. могут быть собственные методы, а могут быть унаследованные методы


  приимер классов в js
   
  class Comment { 
    constructor(text) {
      this.text = text
      this.votesQty = 0
    }

    upvote() {
      this.votesQty += 1
    }
  }

  в этом классе есть переменная this - специальная переменная , которая указывает на экземпляр класса. такой класс это всего навсего шаблон для
  создания объекта и когда мы будем создавать новый экземпляр такого класса, то this  автоматически будет ссылаться на такой новый экземпляр.
  И ссылаясь на новый конкретный экземпляр класса мы можем внутри класса(внутри методов класса и саойств класса) менять собственные свойства и методы 
  конкретного экземпляра.

  В данном конкретном примере в методе constructor есть два присваивания this.text = text и this.votesQty = 0. У нас есть один параметр text т.е при
  выфзове такого метода, который называется constructor мы передаем значения для параметра text и далее внутри этого конуструктора мы конкретному 
  экземпляру этого класса Comment добавляем свойство text и значение этого свойства text будет значение параметра text, которое было передано в качестве
  аргумента в вызове этого метода т.е у нового экземпляра этого класса появится собственное свойство text  с каким то текстовым значением, которое мы 
  передали внутри вызова функции constructor. Таким же способом мы добавили свойство votesQty и как мы видим справа от знака присваивания стоит 0, как 
  начальное значение

  СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА Comment

  const firstComment = new Comment('First comment')  - используем ключевое слово new(префиксый унарный оператор), для создания экземпляра класса

  СОБСТВЕННЫЕ СВОЙСТВА ЭКЗЕМПЛЯРА

  после создания нового экзкмпляра класса Comment у переменной firstComment появятся свои собственные свойства. Если мы напечатаем в консоль 
  firstComment то мы увидим структуру объекта


  НАСЛЕДОВАНИЕ ПО ЦЕПОЧКЕ 

  если после создание переменной firstComment и поставить точку при вызове, то можно увидеть все методы и свойства доступные на уровне
   объекта firstComment - собственные методы и методы на уровне объекта 

